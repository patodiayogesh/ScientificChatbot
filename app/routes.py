import logging

from fastapi import (
    APIRouter,
    Depends,
    Form,
    HTTPException,
    UploadFile,
    File,
)

from app.services.upload_pdf_service import UploadPdfService
from app.services.pdf_information_extraction_service import PdfInformationExtractionService
from app.services.db_service import get_firebase_db, DatabaseService
from app.services.chatbot_service import ChatbotService

router = APIRouter()
logger = logging.getLogger(__name__)

@router.get(
    "/health",
    summary="Service Health Check",
    response_description="Returns status of the service",
    tags=["System"],
    responses={
        200: {
            "description": "Service is healthy",
            "content": {
                "application/json": {
                    "example": {"status": "ok"}
                }
            },
        }
    },
)
def health_check():
    """
    Endpoint to check if the service is up and running.

    This can be used for monitoring, health probes, or load balancer checks.

    ### Example response:
    ```json
    {
        "status": "ok"
    }
    ```

    ### Usage:
    - Use `/health` to verify deployment status
    - Returns a `200 OK` if service is operational
    """
    logger.info("Health check endpoint successfully accessed.")
    return {"status": "ok"}

@router.post(
    "/pdf_upload",
    summary="Upload a PDF or ZIP file",
    response_description="Parsed data extracted from uploaded PDF(s)",
    tags=["PdfUpload"]
)
def pdf_upload(
        file: UploadFile = File(...,
                                description="Upload a single `.pdf` file or a `.zip` containing multiple PDFs."
                                )
):
    """
        Upload a single PDF or ZIP archive of PDFs.

        This endpoint processes the uploaded file, extracts text/data from valid PDFs,
        and stores the information in the database.

        **Accepted File Types**:
        - `.pdf`: Individual PDF document
        - `.zip`: A zipped archive of multiple PDF files

        **Constraints**:
        - Only **one** file may be uploaded per request.
        - All files inside a `.zip` must be valid `.pdf` files.

        ### Example using `curl`:
        ```bash
        curl -X 'POST' 'http://localhost:8000/pdf_upload' \
             -H 'accept: application/json' \
             -H 'Content-Type: multipart/form-data' \
             -F 'file=@example.pdf;type=application/pdf'
        ```
    """
    try:
        logger.info("Received file upload request.")
        if not file:
            logger.error("No file uploaded.")
            raise HTTPException(status_code=400, detail="No file uploaded.")
        if not (file.filename.endswith('.pdf') or file.filename.endswith('.zip')):
            logger.error("Invalid file type uploaded.")
            raise HTTPException(status_code=400, detail="Only .pdf or .zip files are allowed.")

        new_uploaded_files = UploadPdfService().upload(file)
        if new_uploaded_files is None or len(new_uploaded_files) == 0:
            logger.error("No valid PDF files found in the uploaded file.")
            raise ValueError("No valid PDF files found in the uploaded file.")
        logger.info(f"Successfully uploaded {len(new_uploaded_files)} file(s).")

        # Process the uploaded files
        pdf_information_extraction_service = PdfInformationExtractionService()
        extracted_data = pdf_information_extraction_service.run(new_uploaded_files)

        # Add the extracted data to the database
        db_service = DatabaseService()
        db_service.add_documents(extracted_data)

        return extracted_data
    except Exception as e:
        logger.error(f"Error while uploading/processing files: {e}")
        raise HTTPException(status_code=500, detail=f"Error processing file: {str(e)}")


@router.post(
    "/chatbot",
    summary="Chatbot Query Endpoint",
    response_description="Response generated by the chatbot",
    tags=["Chatbot"],
    responses={
        200: {
            "description": "Successful chatbot response",
            "content": {
                "application/json": {
                    "example": {
                        "response": "This is a scientific chatbot"
                    }
                }
            },
        },
        400: {
            "description": "Bad request, empty query",
            "content": {
                "application/json": {
                    "example": {
                        "detail": "Query cannot be empty."
                    }
                }
            },
        },
        500: {
            "description": "Internal server error while processing query",
            "content": {
                "application/json": {
                    "example": {
                        "detail": "Error processing query: <error message>"
                    }
                }
            },
        },
    },
)
def chatbot(
        query: str = Form(...,
                          description="The user query string to send to the chatbot."
                          )
):
    """
    Handle chatbot queries by passing the user input to the ChatbotService.

    - Accepts a single form parameter `query` which contains the user input.
    - Returns the chatbot-generated response.

    ### Example using curl:
    ```bash
    curl -X POST "http://localhost:8000/chatbot" \
         -H "Content-Type: application/x-www-form-urlencoded" \
         -d "query=Compare paper X and Y?"
    ```

    ### Response example:
    ```json
    {
        "response": "Paper X and Paper Y talk about LLMs"
    }
    ```
    """
    try:
        logger.info(f"Received chatbot query: {query}")
        if not query:
            logger.error("Empty query received.")
            raise HTTPException(status_code=400, detail="Query cannot be empty.")

        db_service = DatabaseService()

        service = ChatbotService()
        response = service.get_response(query=query, db_service=db_service)

        logger.info("Chatbot query processed successfully.")
        return {"response": response}
    except Exception as e:
        logger.error(f"Error processing chatbot query: {e}")
        raise HTTPException(status_code=500, detail=f"Error processing query: {str(e)}")